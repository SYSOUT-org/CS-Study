# 브라우저 주소창에 {my-server-origin}/member 로 요청을 보내면

## 첫번째, 도메인 네임으로부터 IP 주소를 얻는 과정

- 브라우저 DNS 캐시 확인
- OS의 hosts 파일 확인
- OS의 DNS 캐시 확인
- ISP DNS 서버에 질의 (없으면 Root -> TLD -> 네임서버 순으로 질의)

---

## 두번째, 보내고자 하는 데이터를 패킷으로 만드는 과정

1. 응용 계층(Spring Boot App, Node.js APP…)에서 에서 선택한 L7 프로토콜(HTTP..)에 맞는 메시지를 만듬
2. 전송 계층에서 응용계층 메시지의 크기를 보고 필요하다면 분할, TCP 헤더(출발, 목적지 포트번호…) 를 붙여 TCP 세그먼트들을 생성
3. 네트워크 계층에서 TCP 세그먼트의 크기를 보고 필요하다면 분할, IP 헤더(출발, 목적지 IP 주소…) 를 붙여 IP 패킷들을 생성
4. 데이터링크(물리) 계층에서 IP 패킷에 이더넷 헤더(출발, 목적지 MAC 주소..)와 트레일러를 추가한 이더넷 프레임을 생성, 여기선 분할 안 함

전체과정 도식화

```
[응용 계층 데이터]
     ↓
[TCP 헤더 + 응용 계층 데이터]
     ↓
[IP 헤더 + TCP 헤더 + 응용 계층 데이터]
     ↓
[이더넷 헤더 + IP 헤더 + TCP 헤더 + 응용 계층 데이터 + 이더넷 트레일러]
```

---

## 세번째, 패킷이 목적지로 가는 과정

1. 출발지 호스트의 패킷 전달
    - 목적지가 같은 네트워크인지 서브넷 마스크로 확인
    - 다른 네트워크면 게이트웨이(공유기)로 전달
2. 공유기의 패킷 처리
    - NAT로 내부 IP를 공인 IP로 변환
    - 변환된 패킷을 ISP 라우터로 전달
3. 라우터들의 패킷 전달
    - 각 라우터는 라우팅 테이블에서 최적 경로 선택
    - 선택 기준: 홉 카운트, 대역폭, 지연 시간 등
    - 패킷은 여러 라우터를 거쳐 목적지로 이동
4. 패킷 전달 경로

```
클라이언트 PC -> 공유기 -> 지역 ISP -> 코어 라우터 -> 인터넷 교환점 -> 목적지 ISP -> 목적지 서버
```

---

## 네번째, 찾은 서버의 운영체제와 3-way handshake 를 하는 과정

1. 클라이언트의 연결 요청
    - SYN 패킷 전송 (시퀀스 번호 포함)
    - TCP 상태: CLOSED → SYN_SENT
2. 서버의 연결 응답
    - SYN + ACK 패킷 전송
    - ACK 번호는 클라이언트의 시퀀스 번호 + 1
    - TCP 상태: LISTEN → SYN_RECEIVED
3. 클라이언트의 연결 수락
    - ACK 패킷 전송
    - 서버의 시퀀스 번호 + 1을 ACK 번호로 사용
    - TCP 상태: SYN_SENT → ESTABLISHED

---

## 다섯번째, 연결이 된 서버의 스프링 부트 애플리케이션이 요청을 처리하는 과정

1. 운영체제의 패킷 전달
    - TCP/IP 스택이 IP 패킷→TCP 세그먼트→원본데이터로 재조립 후 소켓 버퍼에 저장
    - 톰캣의 요청에 의해 열려있던 소켓을 통해 톰캣으로 전달
2. 톰캣의 요청 처리
    - Connector가 Socket으로부터 데이터 수신
    - HTTP 메시지 파싱
    - HttpServletRequest/Response 객체 생성
    - 스레드 풀에서 작업 스레드 할당
3. 스프링의 요청 처리
    - 필터 체인 실행 (인코딩, 보안 등)
    - DispatcherServlet이 요청 받아 GET /member 컨트롤러로 전달
    - 핸들러 어댑터가 파라미터 바인딩, 검증 수행
4. 비즈니스 로직 실행
    - 컨트롤러에서 서비스 계층 호출
    - 연산, 트랜잭션 처리, 데이터베이스 작업 수행
5. 응답 생성 및 반환
    - 처리 결과를 응답 객체에 담아 변환(JSON 등)
    - 톰캣이 HTTP 응답 생성
    - 운영체제에게 줌, 클라이언트의 브라우저로 전송
    - 브라우저는 데이터를 파싱, 화면에 띄움