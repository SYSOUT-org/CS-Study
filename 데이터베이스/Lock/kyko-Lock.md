## 동시성 제어

DBMS는 다수의 사용자가 동시에 접근하는 환경을 가정하기 때문에, 여러 트랜잭션이 동시에 실행될 때 데이터의 **일관성을 보호**해야 한다. 이러한 트랜잭션 간 상호작용을 **제어하는 기법**을 동시성 제어(Concurrency Control)라고 한다.
![image](https://github.com/user-attachments/assets/ccbda298-5169-47c8-898a-801de86eac3e)

동시성 제어는 **병행 제어(Concurrency Control)** 라고도 불리며, 여러 트랜잭션이 동시에 실행될 때 **트랜잭션을 직렬화 하는 수행**을 보장한다.

> 동시성이 높아질수록 데이터베이스의 일관성이 깨질 가능성이 증가한다.
> ![image](https://github.com/user-attachments/assets/84e2abed-9826-45d5-a76c-233ca7e41df5)
>
> 즉, 동시성과 일관성은 반비례 관계에 있다.


DBMS는 이러한 문제를 해결하기 위해 다양한 동시성 제어 기법을 제공한다.

### 동시성 제어 기법

- **잠금(Locking)**
- **타임스탬프(Time Stamp)**
- **낙관적 검증(Optimistic Concurrency Control)**
- **다중버전 병행제어 기법(MVCC))**

---

## 잠금(Locking) 기법
잠금(Locking)은 하나의 트랜잭션이 실행되는 동안 특정 데이터 항목에 대해 다른 트랜잭션의 동시 접근을 제한하여, **상호배제(Mutual Exclusive)** 를 보장하는 기법이다.
하나의 트랜잭션이 데이터 항목에 잠금(lock)을 설정하면, 해당 잠금을 설정한 트랜잭션이 해제(unlock)할 때까지 다른 트랜잭션은 해당 데이터를 수정하거나 읽을 수 없다.
이를 통해 **일관성(Consistency)** 을 유지할 수 있다.
![image](https://github.com/user-attachments/assets/568a47e5-8e5d-4a51-b90e-07dfe90d7348)

### 잠금 연산 종류
잠금 연산은 데이터에 대한 연산의 성격에 따라 **공유 락** 과 **배타 락** 으로 나뉜다.
트랜잭션이 데이터 항목에 접근할 때 두 가지 잠금 방식 중 하나를 사용하며, 잠금을 해제할 때는 unlock 연산을 이용한다.

##### 공유 락 (Shared Lock, Read Lock, S-Lock)
- 데이터를 변경하지 않는 읽기 작업을 위해 잠그는 것을 의미
- 다른 세션에서 해당 데이터에 공유 Lock을 걸고 접근할 수 있음 → 정합성이 지켜지기 때문에 다른 세션의 공유 Lock을 막을 이유가 없음
- 다른 세션에서는 해당 데이터에 배타 Lock을 걸고 접근할 수 없음

##### 배타 락 (Exclusive Lock, Write Lock, X-Lock)
- 데이터를 변경하는 작업을 위해 잠그는 것을 의미
- 다른 세션에서 해당 데이터에 공유 Lock을 걸고 접근할 수 없음 → 정합성이 안지켜질 수 있음
- 다른 세션에서 해당 데이터에 배타 Lock을 걸고 접근할 수 없음


## 락(Lock)

트랜잭션이 특정 데이터에 대한 **처리 순서를 보장**하기 위한 방법으로, 여러 트랜잭션이 동일한 자원에 동시에 접근하는 경우 **순차적으로 하나의 트랜잭션만 변경할 수 있도록 제어**하는 기능이다.

### 락(Lock)의 종류

#### 1. 낙관적 락(Optimistic Lock, 애플리케이션 레벨 락)
- 데이터 갱신 시 충돌 가능성이 낮다고 가정하는 방식
- 주로 동시 업데이트가 거의 없는 경우 사용
- `Version` 컬럼을 추가하여 충돌을 방지
- 커밋 전에 충돌 여부를 확인하며, 충돌 발생 시 롤백을 수행해야 함 (개발자가 직접 처리 필요)

#### 2. 비관적 락(Pessimistic Lock, DBMS 제공 락)
- 동일한 데이터를 동시에 수정할 가능성이 높을 때 사용하는 방식
- 외부 시스템과 연동하거나, 데이터 충돌 가능성이 높은 경우 사용

##### 공유 락 (Shared Lock, Read Lock, S-Lock)
- **데이터를 읽을 때** 설정하는 락
- 여러 트랜잭션이 동시에 공유 락을 설정할 수 있음
- 하지만 **배타 락이 설정된 데이터에는 접근할 수 없음**

##### 배타 락 (Exclusive Lock, Write Lock, X-Lock)
- **데이터를 수정할 때** 설정하는 락
- 배타 락이 설정된 데이터는 **다른 트랜잭션이 읽거나 수정할 수 없음**
- 동시에 하나의 트랜잭션만 데이터 변경 가능

---

## 블로킹(Blocking)

### 블로킹이란?
- **트랜잭션 간 락 경합**이 발생하여 특정 트랜잭션이 **작업을 진행하지 못하는 상태**
- **공유 락끼리는 블로킹이 발생하지 않지만, 배타 락은 블로킹을 발생시킴**

### 블로킹 예시
1. **세션 A가 공유 락 설정** → **세션 B가 배타 락 설정 시도** → 세션 B는 **세션 A의 락 해제(커밋/롤백) 전까지 블로킹**
2. **세션 A가 배타 락 설정** → **세션 B도 동일한 데이터에 배타 락 설정 시도** → 세션 B는 세션 A가 **락을 해제할 때까지 블로킹**

블로킹을 해소하려면 **이전 트랜잭션이 완료(커밋 또는 롤백)되어야 한다**.

---

## 데드락(Deadlock)

### 데드락이란?
- 두 개 이상의 트랜잭션이 **서로가 보유한 락을 기다리며 무한정 대기하는 상태**
- 즉, **서로의 블로킹을 해결할 수 없는 상태**

### 데드락 발생 조건 (Coffman 조건)
1. **상호 배제 (Mutual Exclusion)**: 자원은 한 번에 하나의 트랜잭션만 사용할 수 있음.
2. **점유 및 대기 (Hold and Wait)**: 자원을 가진 트랜잭션이 추가 자원을 요청하며 대기함.
3. **비선점 (No Preemption)**: 다른 트랜잭션이 강제로 자원을 해제할 수 없음.
4. **순환 대기 (Circular Wait)**: 여러 트랜잭션이 순환 형태로 자원을 대기함.

### 데드락 예시: 식사하는 철학자 문제
- 철학자들이 왼쪽, 오른쪽 포크를 동시에 사용해야 식사가 가능
- 각 철학자가 왼쪽 포크를 집고 오른쪽 포크를 기다리는 상황에서 데드락 발생 가능

### MySQL의 데드락 해결 방식
- MySQL은 **데드락을 자동 감지**하여 해결
- 데드락 감지 시 **트랜잭션 중 하나를 강제 롤백**하고 다른 트랜잭션을 진행

---

DBMS는 동시성과 데이터 일관성을 유지하기 위해 다양한 동시성 제어 기법을 제공한다. 락(Lock)은 가장 일반적인 동시성 제어 기법이며, 이를 적절히 사용하지 않으면 **블로킹과 데드락이 발생**할 수 있다. 따라서 데이터베이스 설계 및 트랜잭션 처리 시 락의 종류와 특성을 이해하고 적절하게 활용하는 것이 중요하다.
