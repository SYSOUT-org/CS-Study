## 동시성 제어

DBMS는 다수의 사용자가 동시에 접근하는 환경을 가정하기 때문에, 여러 트랜잭션이 동시에 실행될 때 데이터의 **일관성을 보호**해야 한다. 이러한 트랜잭션 간 상호작용을 **제어하는 기법**을 동시성 제어(Concurrency Control)라고 한다.
![image](https://github.com/user-attachments/assets/ccbda298-5169-47c8-898a-801de86eac3e)

동시성 제어는 **병행 제어(Concurrency Control)** 라고도 불리며, 여러 트랜잭션이 동시에 실행될 때 **트랜잭션을 직렬화 하는 수행**을 보장한다.

> 동시성이 높아질수록 데이터베이스의 일관성이 깨질 가능성이 증가한다.
> ![image](https://github.com/user-attachments/assets/84e2abed-9826-45d5-a76c-233ca7e41df5)
>
> 즉, 동시성과 일관성은 반비례 관계에 있다.


DBMS는 이러한 문제를 해결하기 위해 다양한 동시성 제어 기법을 제공한다.

### 동시성 제어 기법

- **잠금(Locking)**
- **타임스탬프(Time Stamp)**
- **낙관적 검증(Optimistic Concurrency Control)**
- **다중버전 병행제어 기법(MVCC))**

---

## 잠금(Locking) 기법
잠금(Locking)은 하나의 트랜잭션이 실행되는 동안 특정 데이터 항목에 대해 다른 트랜잭션의 동시 접근을 제한하여, **상호배제(Mutual Exclusive)** 를 보장하는 기법이다.
하나의 트랜잭션이 데이터 항목에 잠금(lock)을 설정하면, 해당 잠금을 설정한 트랜잭션이 해제(unlock)할 때까지 다른 트랜잭션은 해당 데이터를 수정하거나 읽을 수 없다.
이를 통해 **일관성(Consistency)** 을 유지할 수 있다.
![image](https://github.com/user-attachments/assets/568a47e5-8e5d-4a51-b90e-07dfe90d7348)

### 잠금 연산 종류
잠금 연산은 데이터에 대한 연산의 성격에 따라 **공유 락** 과 **배타 락** 으로 나뉜다.
트랜잭션이 데이터 항목에 접근할 때 두 가지 잠금 방식 중 하나를 사용하며, 잠금을 해제할 때는 unlock 연산을 이용한다.

##### 공유 락 (Shared Lock, Read Lock, S-Lock)
- 데이터를 변경하지 않는 읽기 작업을 위해 잠그는 것을 의미
- 다른 세션에서 해당 데이터에 공유 Lock을 걸고 접근할 수 있음 → 정합성이 지켜지기 때문에 다른 세션의 공유 Lock을 막을 이유가 없음
- 다른 세션에서는 해당 데이터에 배타 Lock을 걸고 접근할 수 없음

##### 배타 락 (Exclusive Lock, Write Lock, X-Lock)
- 데이터를 변경하는 작업을 위해 잠그는 것을 의미
- 다른 세션에서 해당 데이터에 공유 Lock을 걸고 접근할 수 없음 → 정합성이 안지켜질 수 있음
- 다른 세션에서 해당 데이터에 배타 Lock을 걸고 접근할 수 없음

---

## 낙관적 락, 비관적 락

### 낙관적 락(Optimistic Lock, 애플리케이션 레벨 락)
- 데이터 갱신 시 충돌 가능성이 낮다고 가정하는 방식
- 주로 동시 업데이트가 거의 없는 경우 사용
- `Version` 컬럼을 별도로 추가하여 충돌을 방지
- 커밋 전에 충돌 여부를 확인하며, 충돌 발생 시 롤백을 수행해야 함 (개발자가 직접 처리 필요)

### 비관적 락(Pessimistic Lock, DBMS 제공 락)
- 동일한 데이터를 동시에 수정할 가능성이 높을 때 사용하는 방식
- 외부 시스템과 연동하거나, 동시 업데이트가 빈번한 경우 사용
- 공유락, 배타 락 등이 있음

---

## 블로킹(Blocking)

### 블로킹이란?
- **트랜잭션 간 락 경합**이 발생하여 특정 트랜잭션이 **작업을 진행하지 못하는 상태**
- **공유 락끼리는 블로킹이 발생하지 않지만, 배타 락은 블로킹을 발생시킴**

### 블로킹 예시
![image](https://github.com/user-attachments/assets/ac5b5581-cc60-4233-8019-d668c254c44a)
세션 A가 공유 락 설정 → 세션 B가 배타 락 설정 시도 → 세션 B는 세션 A의 락 해제(커밋/롤백) 전까지 블로킹

블로킹을 해소하려면 **이전 트랜잭션이 완료(커밋 또는 롤백)되어야 한다**.

---

## 데드락(Deadlock)

### 데드락이란?
- 두 개 이상의 트랜잭션이 **서로가 보유한 락을 기다리며 무한정 대기하는 상태**
- 즉, **서로의 블로킹을 해결할 수 없는 상태**
![image](https://github.com/user-attachments/assets/0e7a4cf0-e067-4d2b-868b-60c15cda748c)


### 데드락 발생 조건 (Coffman 조건)
1. **상호 배제 (Mutual Exclusion)**: 자원은 한 번에 하나의 트랜잭션만 사용할 수 있음.
2. **점유 및 대기 (Hold and Wait)**: 자원을 가진 트랜잭션이 추가 자원을 요청하며 대기함.
3. **비선점 (No Preemption)**: 다른 트랜잭션이 강제로 자원을 해제할 수 없음.
4. **순환 대기 (Circular Wait)**: 여러 트랜잭션이 순환 형태로 자원을 대기함.

### 식사하는 철학자들 문제
![image](https://github.com/user-attachments/assets/a38e2e93-8d49-443d-b482-3600bcc71a09)
상황: 
철학자들은 생각하거나, 밥을 먹거나, 배가 고프거나 3가지 상태를 가질 수 있다.
철학자들은 밥을 먹을 때 왼쪽 포크와 오른쪽 포크를 각 손에 하나씩 들어야 식사를 할 수 있다.
하지만 사람이 5명인데 포크는 5개밖에 없다. 그래서 최대 2명만 동시에 밥을 먹을 수 있다.
### 데드락 발생 조건
- 철학자들은 포크를 공유할 수 없다.(상호 배제)
- 자신의 왼쪽에 앉은 철학자가 포크를 놓을 때까지 기다린다.(점유 대기)
- 철학자들은 왼쪽 철학자의 포크를 빼앗을 방법이 없다.(선점 불가)
- 각 철학자들은 자신의 왼쪽 철학자의 포크를 대기한다.(순환대기)

MySQL에서는 데드락을 자동으로 감지하여 데드락 상황이 되면 하나의 트랜잭션을 롤백하고 종료하여 데드락을 해결한다.

---

## 참고자료
[동시성 제어 기법](https://medium.com/pocs/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EA%B8%B0%EB%B2%95-%EC%9E%A0%EA%B8%88-locking-%EA%B8%B0%EB%B2%95-319bd0e6a68a)
