# 🚩 락 (Lock) 
- 트랜잭션(= DB의 나누어지지 않는 최소한의 처리 단위) 처리의 순차성을 보장하기 위한 방법 🟰 **순차적 처리 보장**
- 동시성을 제어하기 위한 기능 🟰 **동시성 제어**
- 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 하나의 커넥션만 변경할 수 있게 해주는 기능 🟰 **데이터 무결성 유지**

> 👉🏻 *수강신청* 예시 : 많은 학생들이 동시에 특정 강의를 신청 ➡️ 강의의 최대 정원이 50명인데 강의가 1명의 정원이 남았을 경우, 동시에 2명이 신청을 시도하면 정원을 초과하는 문제 발생 
‼️ 이를 방지하기 위해 **락**이 사용
![lock](https://velog.velcdn.com/images/sapientia/post/2535a3a0-0783-435e-8963-1385673e93d3/image.png)



## 📌 동시성 문제 해결 방법 (Lock 종류)
### ✔️ 낙관적 락(Optimistic Lock)
- 낙관적 락은 자원에 **락을 걸지 않고**, 동시성 문제가 발생하면 그 때 처리하도록 진행
- **데이터 충돌의 발생 가능성이 적을 경우**에 비관적 락보다 성능이 좋음
- 낙관적 락은 주로 버전 관리를 통해 구현되며, 충돌 발생 시 갱신 실패를 알리고 다시 시도하도록 설계
- 낙관적 락은 데이터 충돌이 자주 일어나지 않을 것이라고 예상하는 환경에서 선호 / 조회 작업이 많아 동시 접근 성능이 중요한 환경에서 선호

### ✔️ 비관적 락 (Pessimistic Lock)
- 비관적 락은 트랜잭션이 데이터를 사용할 때 해당 데이터에 **락을 걸어서** 다른 트랜잭션이 데이터를 변경할 수 없도록 진행
- 비관적 락은 충돌 가능성이 높은 환경에서 선호 / 데이터의 무결성이 중요한 환경에서 선호

👉🏻 충돌이 발생했을 때, 비관적 락은 트랜잭션을 롤백하면 끝
👉🏻 하지만 낙관적 락은 수동 롤백 처리뿐만 아니라, 성능 면에서도 update를 한번씩 더 해줘야 함


#### 🔍 공유락 (Shared Lock; Read Lock)
- **데이터를 읽을때** 사용되어지는 Lock
- 공유 Lock끼리는 동시에 접근 가능
  - 즉, 하나의 데이터를 읽는 것은 여러 사용자가 동시에 읽을 수 있음   
  🟰 하지만, **`공유 Lock`이 설정된 데이터**에 `베타 Lock`을 사용할 수는 **없음**
  👉🏻 하나의 세션에서 읽기 작업을 수행할 때, 다른 세션에서 해당 데이터를 읽어도 데이터의 정합성은 지켜짐 ➡️ 다른 세션의 공유 Lock을 막을 필요 없음
  👉🏻 하나의 세션에서 읽기 작업을 수행할 때, 다른 세션에서 해당 데이터에 쓰기 작업을 수행한다면 기존 세션의 작업 결과가 달라질 수 있기 때문에 데이터 정합성이 지켜지지 않음 ➡️ 다른 세션의 베타 Lock을 막아야함

> 세션 A가 특정 데이터를 읽기 위해 공유 Lock을 획득했고,   
다른 세션 B도 같은 데이터를 공유 Lock을 걸고 읽을 수 있지만,   
**어떤 세션도 해당 데이터를 배타 Lock을 걸고 수정할 수 없음**

#### 🔍 베타락 (Exclusive Lock; Write Lock)
- **데이터를 변경**하고자 할때 사용되어지는 Lock
- 베타락은 **Lock이 해제**될 때까지 **다른 트랜잭션(읽기 포함)은 해당 리소스에 접근 불가**
  👉🏻 하나의 세션에서 쓰기 작업을 수행할 때, 다른 세션에서 해당 데이터를 읽는다면 작업 결과가 달라질 수 있기 때문에 데이터 정합성이 지켜지지 않음 ➡️ 다른 세션의 공유 Lock윽 막아야함 

> 세션 A가 특정 데이터를 쓰기 위해 배타 Lock을 획득했고,   
**어떤 세션도 해당 데이터를 읽기 위해 공유 Lock을 걸고 읽는 것이 불가능하고,   
쓰기 위해 배타 Lock을 걸고 쓰는 것이 불가능**

## 📌 Lock의 설정 범위 (LEVEL)
### ✔️ 데이터베이스
데이터베이스 범위의 Lock은 전체 데이터베이스를 기준으로 lock 하는 것
(1개의 세션만이 DB의 데이터에 접근이 가능)

### ✔️ 파일
데이터베이스 파일을 기준으로 Lock을 설정
파일이란 테이블, row 등과 같은 실제 데이터가 쓰여지는(Write) 물리적인 저장소

### ✔️ 테이블
테이블 수준의 Lock은 테이블을 기준으로 Lock을 설정
이는 테이블의 모든 행을 업데이트 하는 등의 전체 테이블에 영향을 주는 변경을 수행할 때 유용
(DDL구문과 함께 사용되며 DDL Lock이라고도 함)

### ✔️ 페이지와 블럭
파일의 일부인 페이지와 블록을 기준으로 Lock을 설정

### ✔️ 컬럼
컬럼 기준의 Lock은 컬럼을 기준으로 Lock을 설정

### ✔️ 행(Row)
행 수준의 Lock은 1개의 행(Row)를 기준으로 Lock 설정

## 📌 블로킹 (Blocking)
**Lock 간 (베타-베타, 베타-공유)의 경합이 발생하여 특정 트랜잭션이 작업을 진행하지 못하고 멈춰선 상태**
  - 위에서 설명했듯이, 공유락끼리는 블로킹 발생 ❌ 
  - 베타락은 블로킹을 발생 ⭕
### ✔️ 블로킹 해소 
- 이전의 트랜잭션이 완료(`Commit` / `Rollback`)되어야 함
  - 뒤에 들어온 트랜잭션은 이전 트랜잭션이 마무리되어야 이후 진행이 가능 
 🟰 성능에 좋지 않음 🟰 경합을 최소화할 필요가 있음
 👉🏻 commit한 후에 배타락을 설정하면 블로킹 상태에 진입해 대기 상태였던 트랜잭션이 정상적으로 작업 수행
![blocking](https://velog.velcdn.com/images/sapientia/post/c839702a-feb6-4154-8373-ec06f2d942c4/image.png)




**해결방안**
- 트랜잭션 작업 단위를 최대한 적게 구성하기
- 동일한 데이터를 동시에 변경하는 작업을 하지 않도록 설계하기
- 트랜잭션이 활발한 주간에는 대용량 데이터 작업 수행을 지양하기

## 📌 교착상태 (Dead Lock)
**두 트랜잭션이 각각 Lock을 설정하고 다음 서로의 Lock에 접근하여 값을 얻어오려고 할 때 이미 각각의 트랜잭션에 의해 Lock이 설정되어 있기 때문에 양쪽 트랜잭션 모두 영원히 처리가 되지 않게 되는 상태**
🟰 트랜잭션 A와 B가 서로 상대방의 자원을 기다리며 블로킹 상태에 빠져, 양쪽 모두 작업을 진행할 수 없는 상황

👉🏻 교착 상태가 발생하면 DBMS에서는 둘 중 한 트랜잭션에 에러를 발생시킴으로써 데드락 문제를 해결 
👉🏻 교착 상태가 발생할 가능성을 줄이기 위해서는 접근 순서를 동일하게 하는 것이 중요
![Dead Lock](https://velog.velcdn.com/images/sapientia/post/062184e7-3039-4631-9376-4f9ad0684551/image.png)


**해결방안**
- 타임아웃 설정
- 접근 순서 고정

---
참고자료
- https://shuu.tistory.com/88
- https://ksh-coding.tistory.com/121
- https://sabarada.tistory.com/121