# Lock을 사용하는 이유

- 여러 사용자가 동시에 같은 데이터에 접근했을 때 문제가 생길 수 있는 상황을 예방하기 위함.
- 트랜잭션 내부에서의 순차성을 보장하도록 하여, 원하는 결과가 나올 수 있게 만드는 것이 Lock.
- 즉, 동시성을 제어하기 위해 사용하는 기법

## 어떨 때 문제가 생겼다고 할 수 있는가.

- 수강 신청 가능 인원이 1명이 남았다고 가정한다. 이 때, A와 B라는 학생이 동시에 수강 신청을 할 경우 단 한 명이 해당 과목을 수강할 수 있어야 한다. 하지만, 동시성 문제를 고려하지 않았을 경우, 두 사람 모두 해당 과목을 수강할 수 있을 가능성이 생긴다.

# Lock의 종류

## Shared Lock(공유 잠금)

- 데이터를 변경하지 않는 읽기 작업을 할 때 잠그는 것으로 읽기 잠금이라고 한다.
- 여러 트랜잭션이 동시에 읽는 것을 허용한다.
- 주로 데이터를 조회(Select)할 경우가 많을 때 사용한다.

## Exclusive Lock(배타 잠금)

- 데이터를 변경하는 작업을 위해 잠그는 것으로, 쓰기 잠금이라고 한다.
- 데이터를 변경하고자 할 때 사용하게 되는데, **다른 세션이 해당 자원에 접근하는 것을 방지**합니다. 락이 해제될 때까지 다른 트랜잭션은 해당 리소스에 접근할 수 없으며, **기존 트랜잭션이 끝났을 경우 비로소, 해당 리소스에 접근할 수 있습니다.**

## Pessimistic Lock(비관적 락)

- 데이터 충돌이 발생할 가능성이 높다고 우선 가정한다. 그렇기 때문에 읽을 시점에 Lock을 미리 걸어 충돌을 방지한다.
- 읽을 시점에 Lock이 걸리기 때문에, 다른 트랜잭션은 전부 대기 상태가 된다. 따라서 성능 저하가 생길 수 있다.

## Optimistic Lock(낙관적 락)

- 실질적으로 DB에 락을 걸지 않는다. 커밋 시점에 데이터가 다른 트랜잭션에 의해 수정되었는지 버전을 비교해 충돌 여부를 판단한다.
- 충돌이 발생했을 때는, 이전 시점으로 롤백합니다.
- 충돌이 발생하면 `OptimisticLockException`이 발생해 트랜잭션을 재시도 할 수 있다.

| 구분 | 공유 잠금 | 배타 잠금 | 비관적 락 | 낙관적 락 |
| --- | --- | --- | --- | --- |
| 목적 | 데이터 읽기 중 무결성 보장 | 데이터 읽기/쓰기 간의 완전한 독점 보장 | 데이터 충돌을 사전에 방지 | 데이터 충돌을 사후에 감지 |
| 잠금 여부 | 여러 트랜잭션이 동시에 읽기 가능 | 하나의 트랜잭션만이 독점 | 데이터 읽을 때 잠금을 걸어 충돌 예방 | 데이터 읽을 때 잠금이 없기 때문에 커밋 시점에서 충돌 여부를 검사 |
| 성능 | 읽기 성능 좋음 | 쓰기 성능 낮음 | 쓰기 성능 낮음 | 읽기 성능 높음 |
| 적합한 상황 | 읽기 작업이 많을 경우. 업데이트 발생이 빈번하지 않을 경우. | 데이터 변경이 많고 충돌 가능성이 높을 경우 | 데이터 변경이 많고 충돌 가능성이 높을 경우 | 읽기 작업이 많으며 쓰기 작업이 적을 경우 |

## 블로킹

- 한 트랜잭션이 자원을 사용하고 있는 동안에 다른 트랜잭션이 해당 자원에 접근하려고 할 때 대기하는 상황을 블로킹이라고 한다. 이를 해결하기 위해선 결국, 이전 트랜잭션이 커밋이 되거나 롤백이 되어 완료 상태가 되어야만 한다. 즉, 블로킹이 발생한 후에 락이 걸린 트랜잭션이 끝나야만 하는데, 이런 현상이 반복되면 성능에 좋지 않은 영향을 미친다.

## DeadLock(교착상태)

- 두 트랜잭션이 있다고 가정하고, 해당 트랜잭션들은 락이 설정되어 있다. 이 때, 서로의 락에 접근하려고 할 때, 모두 락 설정이 되어 있기 때문에 처리가 될 수 없는 상태를 ‘DeadLock’이라고 한다.
- 이 때 서로 락이 해제되기까지를 기다리기 때문에 영원히 락이 풀리지 않게 된다.
- 그렇기 때문에 락을 사용할 때에는 이 데드락이 걸리지 않는지를 확인해야 한다.

**예시**: 두 개의 스레드가 서로 다른 Lock을 잡고 상대방이 가진 Lock을 기다리는 상황

- 스레드 1이 Lock A를 잡고 Lock B를 기다림
- 스레드 2가 Lock B를 잡고 Lock A를 기다림

➡️ **결과**: 교착 상태 발생
