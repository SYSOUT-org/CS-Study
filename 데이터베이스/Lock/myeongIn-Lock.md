# 데이터베이스 락 (Database Lock)

데이터베이스에서 락(Lock)은 여러 트랜잭션이 동일한 자원(테이블, 레코드 등)에 동시에 접근할 때 데이터 무결성을 보장하기 위한 메커니즘. 
**락**은 동시성 문제를 방지하는 데 중요한 역할을 하며, 이를 이해하면 트랜잭션 처리의 안정성을 확보할 수 있음.
저번 트랜잭션 공부할 때 알았던 사실대로, 시간적인 효율성을 위해 데이터베이스의 병렬 작업(멀티스레드 환경)을 지원하면 데이터 일관성과 무결성이 깨질 수 있다는 단점이 존재했음. (Ex. 레이스컨디션)
이를 해결하기 위한 적절한 격리 수준을 설정해야했음. 이때 사용될 수 있는 기술이 바로 Rock. 물론, 최고 수준의 격리수준을 건다면 DBMS가 작업을 하나씩 순차적으로 해결하는 성능이 될 것이기에, 이 Rock도 상황에 따라 효율적인 전략들이 있을 것임

---

## 1. 락의 필요성
위에 말한 것처럼, 대부분의 데이터베이스 시스템은 효율성을 위해 다수의 사용자가 동시에 데이터를 읽거나 쓸 수 있도록 설계되어 있다. 하지만 동시에 접근하면 다음과 같은 문제가 발생할 수 있었다.

- **Dirty Read**: 한 트랜잭션이 변경한 데이터를 다른 트랜잭션이 커밋 전에 읽는 경우.
- **Lost Update**: 두 트랜잭션이 동시에 데이터를 수정해 한 쪽의 업데이트가 유실되는 경우.
- **Non-Repeatable Read**: 한 트랜잭션이 동일한 데이터를 두 번 읽었을 때 중간에 다른 트랜잭션에 의해 값이 변경되는 경우.

이러한 문제를 방지하기 위해 Rock 기술을 도입할 수 있다.

---

## 2. 락의 유형
### 2.1. **공유 락 (Shared Lock, S Lock)**
- 다른 트랜잭션이 데이터를 읽을 수 있도록 허용하지만, 데이터를 수정하는 것은 금지
- 주로 `SELECT` 문에서 사용

### 2.2. **배타 락 (Exclusive Lock, X Lock)**
- 특정 트랜잭션이 데이터를 수정할 때 사용되며, 다른 트랜잭션이 해당 데이터에 접근하지 못하게 함.
- 주로 `INSERT`, `UPDATE`, `DELETE` 문에서 사용

### 2.3. **의도적 락 (Intent Lock)**
- 트랜잭션이 테이블의 일부 데이터를 잠글 의도가 있다는 것을 나타내는 락
- 상위 수준에서 락 충돌을 미리 방지하기 위해 사용

---

## 3. 락의 범위
데이터베이스 락은 설정되는 범위에 따라 다음과 같이 나뉜다 : 

### 3.1. **행 락 (Row-Level Lock)**
- 특정 행(Row) 단위로 락을 설정
- 높은 동시성을 제공하지만, 락 관리 오버헤드가 발생할 수 있음

### 3.2. **테이블 락 (Table-Level Lock)**
- 테이블 전체에 대해 락을 설정
- 단순하지만 동시성이 낮아짐.

### 3.3. **페이지 락 (Page-Level Lock)**
- 데이터 파일 내의 특정 페이지(일정 크기의 블록)에 대해 락을 설정.

### 3.4. **데이터베이스 락 (Database-Level Lock)**
- 데이터베이스 전체에 락을 설정.

---

## 4. 락과 데드락 (Deadlock)

### 4.1. **데드락의 개념**
- 두 개 이상의 트랜잭션이 서로가 보유한 자원의 락 해제를 기다리는 상태로, 영원히 진행되지 못하는 상황을 말함.

### 4.2. **데드락 발생 예시**
1. 트랜잭션 A가 `Row1`에 락을 건 상태에서 `Row2`에 접근 시도.
2. 트랜잭션 B가 `Row2`에 락을 건 상태에서 `Row1`에 접근 시도.
3. 트랜잭션 A와 B는 서로가 해제하기를 기다리며 데드락 발생.

### 4.3. **데드락 방지 방법**
- **락 순서 지정:** 트랜잭션이 항상 동일한 순서로 자원에 락을 거는 규칙을 설정.
- **타임아웃 설정:** 일정 시간 내에 락이 해제되지 않으면 트랜잭션을 중단.
- **락 강제 해제:** 데드락을 감지하면 시스템이 자동으로 트랜잭션 중 하나를 강제로 롤백.

---

## 5. 락과 트랜잭션 격리 수준
트랜잭션 격리 수준은 락 메커니즘에 큰 영향을 미침. SQL 표준에 정의된 트랜잭션 격리 수준은 다음과 같다 : 

| 격리 수준              | 설명                                                      | 허용되는 문제                             |
|-------------------|---------------------------------------------------------|---------------------------------------|
| **READ UNCOMMITTED** | 다른 트랜잭션의 미완료 변경 내용을 읽을 수 있음.             | Dirty Read, Non-Repeatable Read, Lost Update |
| **READ COMMITTED**   | 커밋된 데이터만 읽을 수 있음.                             | Non-Repeatable Read, Lost Update     |
| **REPEATABLE READ**  | 트랜잭션 동안 동일한 데이터를 반복해서 읽어도 변하지 않음.    | Phantom Read                         |
| **SERIALIZABLE**     | 트랜잭션이 순차적으로 실행되며 완전한 격리 보장.             | 없음                                   |

---

## 6. 락 관리 전략

### 6.1. **락 경합 줄이기**
- 자주 사용하는 테이블이나 행에 대한 락 경합을 줄이기 위해 트랜잭션을 짧게 유지
- 가능한 경우 락을 필요로 하지 않는 쿼리로 대체

### 6.2. **적절한 격리 수준 설정**
- 트랜잭션 격리 수준을 업무의 특성에 맞게 설정하여 락 오버헤드를 최소화

### 6.3. **락 모니터링과 튜닝**
- 데이터베이스의 락 상태를 모니터링하여 비효율적인 락 사용을 식별하고 최적화

---

## 7. 결론
데이터베이스 락은 데이터의 무결성을 보장하는 중요한 메커니즘이지만, 잘못 관리하면 데드락이나 성능 저하의 원인이 될 수 있다. 따라서 락의 유형, 범위, 트랜잭션 격리 수준을 이해하고 적절히 활용하는 것이 중요

---

## 참고 자료
- https://f-lab.kr/insight/understanding-database-locks

