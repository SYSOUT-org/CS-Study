# Database Partitioning

## 개요
서비스가 성장하고 데이터가 늘어날수록 데이터베이스는 자연스럽게 성능 저하를 겪게 된다.
아무리 테이블을 잘 설계했더라도, 삽입되는 레코드가 점점 많아지고 테이블의 규모가 커지면 테이블을 로드하거나 질의하는 성능이 저해될 수 있다.
특히 레코드가 많은 특정 테이블에 부하가 집중되면 병목이 생길 수도 있다.

이러한 문제를 해결하기 위해 **테이블을 물리적으로 분할하여 레코드를 저장하는 기술**, **데이터베이스 분할**, 혹은 영문으로 **데이터베이스 파티셔닝**이 등장했다.
분할되어 저장되는 단위는 **파티션**이라 부른다.
테이블 내의 수 많은 레코드가 효율적으로 저장되어야 하는 경우, 혹은 데이터베이스에 대한 부하의 분산을 고려해야 하는 경우에 유용하게 사용할 수 있는 기술이다.

## 데이터베이스 분할 방법
데이터베이스 분할은 크게 수직적 분할과 수평적 분할로 나눌 수 있다.

### 수직적 분할 (Vertical Partitioning)
**수직적 분할**은 테이블의 **열**(Column) 을 기준으로 테이블을 나누어 저장하는 방식이다.
![image](https://github.com/user-attachments/assets/ffc77185-e3eb-48f2-9eab-bf53d94574b2)

다음과 같은 상황에서 수직적 분할은 유용하다.

- 테이블에 발생하는 트랜잭션 수에 비해 테이블 내에 열이 과도하게 많은 경우
- 특정 컬럼의 데이터 크기가 다른 컬럼보다 현저히 큰 경우
- 보안상의 이유로 특정 데이터만 별도로 관리해야 하는 경우


| 제품 id | 제품 이름 | 제조자 | **제품 설명(분리 대상)** |
| --- | --- | --- | --- |
| … | … | … | … |
| … | … | … | … |

ex) 제품 테이블에 레코드 수가 많고, 제품 설명 컬럼이 매우 큰 데이터를 가지고 있다면,
제품 테이블에 대한 모든 조회마다 제품 설명 정보가 필요한 것이 아닌 이상,
제품 설명 컬럼만 별도의 테이블로 분리하여 필요할 때만 조회하도록 하는 것이 성능상 유리하다.

### 수평적 분할 (Horizontal Partitioning)
**수평적 분할**은 테이블의 **행**(Row)을 기준으로 테이블을 나누어 저장하는 방식이다.
![image](https://github.com/user-attachments/assets/4e6f3e18-7086-4578-ac92-210fad02dca9)

테이블에 수많은 레코드가 존재하고, 테이블의 레코드를 참조할 때마다 모든 레코드를 한 번에 불러들일 필요가 없는 경우 테이블을 수평적으로 분할한다.

> 📌 보통 ‘데이터베이스/테이블 분할’, ‘데이터베이스/테이블 파티셔닝’이라는 용어는 수평적 분할을 의미하는 경우가 많고, 수평적 분할이 대중적으로 활용된다.
>


수평적 분할에는 대표적으로 다음 4가지 방식이 있다.

**1. 범위 분할(Range Partitioning)**

**레코드 데이터가 가질 수 있는 범위를 정의하고, 해당 범위를 기준으로 테이블을 나눈다.**

예를 들어 가입 회원들의 데이터를 관리하는 경우를 가정해보자. 회원들의 가입 연도를 범위로 정의하고, 그 범위에 따라 테이블을 분할한다. 가령 2000년 이전에 가입한 회원들은 p0 파티션에 저장하고, 2000년 부터 2009년 사이에 가입한 회원들을 p1, 2010년부터 2019년 사이 가입한 회원들을 p2 파티션에 저장하는 경우가 있다.

```sql
PARTITION BY RANGE (YEAR(registered_date) ) (
	PARTITION p0 VALUES LESS THAN (2000),
	PARTITION p1 VALUES LESS THAN (2010),
	PARTITION p2 VALUES LESS THAN (2020),
	PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

**2. 목록 분할(List Partitioning)**

레코드 데이터가 특정 목록에 포함된 값을 가질 경우 해당 레코드를 별도의 테이블로 분할한다. 예를 들어 고객의 주소 데이터를 관리하는 경우를 가정해보자. 주소가 Seoul인 고객 레코드는 p0 파티션에 저장하고, Incheon인 고객 레코드는 p1 파티션에 저장하는 경우가 있다.

```sql
PARTITION BY LIST COLUMNS(address) (
	PARTITION p0 VALUES IN ('Seoul', 'Busan', 'Daegu'),
	PARTITION p1 VALUES IN ('Incheon', 'Gwangju', 'Daejeon')
);
```

**3. 해시 분할(Hash Partitioning)**

특정 열 데이터에 대한 해시 값을 기준으로 별도의 테이블로 분할한다. 즉, 파티션별 레코드가 해시 값을 기준으로 균등하게 분배된다. major_id 열을 기준으로 분할하며, 레코드는 major_id 값에 해시 함수를 적용하여 생성된 해시 값에 따라 4개의 파티션으로 나뉘어 저장된다.

```sql
PARTITION BY HASH(major_id)
PARTITIONS 4;
```

**4. 키 분할(Key Partitioning)**

키를 기준으로 별도의 테이블로 분할한다. 즉, 파티션별 레코드가 키를 기준으로 균등하게 분배된다. 예를 들어 학생 데이터를 관리하는 경우 students라는 테이블의 기본 키 id를 기준으로 파티셔닝을 할 수 있다.

```sql
PARTITION BY KEY()
PARTITIONS 2;
```

이렇게 수평적 분할을 통해 만들어진 파티션들은 기본적으로 동일한 데이터베이스 서버 내에 위치한다. 그런데 분할된 테이블이 모두 같은 데이터베이스 서버에 위치할 경우, 해당 서버에 요청이 몰리는 상황에서 부하 분산을 기대하기 어렵다. 이를 해결하기 위한 특별한 수평적 분할 기술로 샤딩이 있다. **샤딩(sharding)**은 **분할된 테이블을 별개의 데이터베이스 서버에 분산하여 저장하는 기술**로, **분할되어 저장된 단위**를 **샤드(shard)**라고 한다. 즉, 샤딩은 샤드를 여러 서버에 분산하여 저장하는 수평적 분할 기법을 말한다. 분할된 샤드들은 여러 서버에 분산되어 저장되기 때문에 부하 분산 효과를 얻을 수 있다.
