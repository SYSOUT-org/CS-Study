# Database Partitioning

## 개요
서비스가 성장하고 데이터가 늘어날수록 데이터베이스는 자연스럽게 성능 저하를 겪게 된다.
아무리 테이블을 잘 설계했더라도, 삽입되는 레코드가 점점 많아지고 테이블의 규모가 커지면 테이블을 로드하거나 질의하는 성능이 저해될 수 있다.
특히 레코드가 많은 특정 테이블에 부하가 집중되면 병목이 생길 수도 있다.

이러한 문제를 해결하기 위해 **테이블을 물리적으로 분할하여 레코드를 저장하는 기술**, **데이터베이스 분할**, 혹은 영문으로 **데이터베이스 파티셔닝**이 등장했다.
분할되어 저장되는 단위는 **파티션**이라 부른다.
테이블 내의 수 많은 레코드가 효율적으로 저장되어야 하는 경우, 혹은 데이터베이스에 대한 부하의 분산을 고려해야 하는 경우에 유용하게 사용할 수 있는 기술이다.

## 데이터베이스 분할 방법
데이터베이스 분할은 크게 수직적 분할과 수평적 분할로 나눌 수 있다.

### 수직적 분할 (Vertical Partitioning)
**수직적 분할**은 테이블의 **열**(Column) 을 기준으로 테이블을 나누어 저장하는 방식이다.
![image](https://github.com/user-attachments/assets/ffc77185-e3eb-48f2-9eab-bf53d94574b2)

다음과 같은 상황에서 수직적 분할은 유용하다.

- 테이블에 발생하는 트랜잭션 수에 비해 테이블 내에 열이 과도하게 많은 경우
- 특정 컬럼의 데이터 크기가 다른 컬럼보다 현저히 큰 경우
- 보안상의 이유로 특정 데이터만 별도로 관리해야 하는 경우


| 제품 id | 제품 이름 | 제조자 | **제품 설명(분리 대상)** |
| --- | --- | --- | --- |
| … | … | … | … |
| … | … | … | … |

ex) 제품 테이블에 레코드 수가 많고, 제품 설명 컬럼이 매우 큰 데이터를 가지고 있다면,
제품 테이블에 대한 모든 조회마다 제품 설명 정보가 필요한 것이 아닌 이상,
제품 설명 컬럼만 별도의 테이블로 분리하여 필요할 때만 조회하도록 하는 것이 성능상 유리하다.

### 수평적 분할 (Horizontal Partitioning)
**수평적 분할**은 테이블의 **행**(Row)을 기준으로 테이블을 나누어 저장하는 방식이다.
![image](https://github.com/user-attachments/assets/4e6f3e18-7086-4578-ac92-210fad02dca9)

테이블에 수많은 레코드가 존재하고, 테이블의 레코드를 참조할 때마다 모든 레코드를 한 번에 불러들일 필요가 없는 경우 테이블을 수평적으로 분할한다.

> 📌 보통 ‘데이터베이스/테이블 분할’, ‘데이터베이스/테이블 파티셔닝’이라는 용어는 수평적 분할을 의미하는 경우가 많고, 수평적 분할이 대중적으로 활용된다.
>


수평적 분할에는 대표적으로 다음 4가지 방식이 있다.

**1. 범위 분할(Range Partitioning)**
레코드의 **값 범위**를 기준으로 테이블을 나눈다.

ex) 회원 가입 연도 기준으로 파티션 분리

회원들의 가입 연도를 범위로 정의하고, 그 범위에 따라 테이블을 분할한다.

- 2000년 이전 → p0
- 2000 ~ 2009년 → p1
- 2010 ~ 2019년 → p2
- 2020년 이후 → p3

```sql
PARTITION BY RANGE (YEAR(registered_date) ) (
	PARTITION p0 VALUES LESS THAN (2000),
	PARTITION p1 VALUES LESS THAN (2010),
	PARTITION p2 VALUES LESS THAN (2020),
	PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

**2. 목록 분할(List Partitioning)**
레코드의 데이터가 특정 목록에 포함된 값을 가질 경우 해당 레코드를 별도의 테이블로 나눈다.

ex) 고객 주소 기준으로 분리

- 'Seoul', 'Busan', 'Daegu' → p0
- 'Incheon', 'Gwangju', 'Daejeon' → p1

```sql
PARTITION BY LIST COLUMNS(address) (
	PARTITION p0 VALUES IN ('Seoul', 'Busan', 'Daegu'),
	PARTITION p1 VALUES IN ('Incheon', 'Gwangju', 'Daejeon')
);
```

**3. 해시 분할 (Hash Partitioning)**
특정 열 데이터에 대한 해시 값을 기준으로 별도의 테이블로 분할한다.

ex) major_id 컬럼을 해시하여 4개 파티션으로 나누기(해시 함수는 major_id에 대한 0~3의 정소를 반환)

```sql
PARTITION BY HASH(major_id)
PARTITIONS 4;
```

**4. 합성 분할(Composite Partitioning)**
두 가지 이상의 분할 방식을 조합해 테이블을 분할하는 방법이다.
![image](https://github.com/user-attachments/assets/c9d8c84b-8969-405b-8e93-af6f90335794)

ex) 지역별 목록 분할 + 가입일 기준 범위 분할
```scss
전체 테이블
├── Seoul (목록 분할)
│     ├── 가입년도 2010~2019 (범위 분할)
│     └── 가입년도 2020~2029 (범위 분할)
└── Busan (목록 분할)
      ├── 가입년도 2010~2019 (범위 분할)
      └── 가입년도 2020~2029 (범위 분할)
```

## 샤딩
수평적 분할을 통해 테이블을 여러 파티션으로 나눌 수 있지만, 이 파티션들이 모두 같은 데이터베이스 서버에 위치한다면 해당 서버에 요청이 몰리는 상황에서 서버 부하 문제는 여전히 발생할 수 있다.
이를 해결하기 위해 등장한 것이 **샤딩(Sharding)** 이다.
**샤딩(Sharding)은 분할된 테이블을 여러 데이터베이스 서버에 분산하여 저장하는 기술**로, **분할되어 저장된 단위**를 **샤드(shard)** 라고 한다. 분할된 샤드들은 여러 서버에 분산되어 저장되기 때문에 부하 분산 효과를 얻을 수 있다.
![image](https://github.com/user-attachments/assets/fd25ce77-2e1d-468c-a69f-5ab38651db8b)

