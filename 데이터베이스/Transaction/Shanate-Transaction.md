

## Transaction

: **DB의 상태**를 **변화**시키기 위해 수행하는 **작업**의 단위.

: 하나 이상의 작업을 묶어 처리하며, 이 작업은 모두 성공하거나 모두 실패해야 한다. → DB의 **정합성**을 지키기 위함이다.

---

다음과 같은 속성을 만족해야 한다.

**Atomicity**(원자성) : 트랜잭션 내의 연산은 데이터베이스에 **전부** 반영이 되거나 **전부** 반영이 되어서는 안 된다. 만일, 전체 반영이 되지 않았다면 해당 트랜잭션은 취소되어야 한다. 그 결과, 트랜잭션은 장애 시 데이터를 복구하는 작업의 단위가 된다.

**Consistency**(일관성) : 트랜잭션 완료 후에 DB는 일관된 상태를 유지해야 한다.

**Isolaiton**(고립성) : 각 트랜잭션은 다른 트랜잭션으로부터 격리되어 있어야 하며, 동시에 실행되어도 서로 영향을 미쳐서는 안 된다.

**Durability**(내구성) : 트랜잭션이 성공하면 그 결과는 영구적으로 저장되어야 한다.

---

### 트랜잭션 제어 명령어(TCL)

**Commit** : 트랜잭션에서의 Commit은 트랜잭션이 끝난 후, DB가 일관성있는 상태에 있을 때 하나의 트랜잭션이 끝났음을 알려주는 연산이다. MySQL에서는 INSERT, DELETE, UPDATE 등의 명령문을 사용해서 데이터 상태를 바꿀 때마다 내부에서 자동적으로 Commit을 실행해 DB에 반영한다.

**Rollback** : 트랜잭션 처리가 비정상적으로 끝나 트랜잭션의 원자성이 어긋난 경우, 트랜잭션을 다시 시작하거나, 부분적으로 처리된 과정을 취소시킨다. 즉, DB의 일관성을 지켜주기 위해 후속조치를 하는 연산으로 보면 된다.

| 표준 명령어 | 문법 | 설명 |
| --- | --- | --- |
| START TRANSACTION | SET TRANSACTION | 트랜잭션의 시작 |
| COMMIT | COMMIT | 트랜잭션의 종료 |
| ROLLBACK | ROLLBACK {TO <savepoint>} | 트랜잭션을 전체 혹은 <savepoint>까지 무효화시킴 |
| SAVE | SAVEPOINT <identifier> | <savepoint>를 만듦 |

---

## 트랜잭션의 상태

![image](https://github.com/user-attachments/assets/8604b0e3-e538-40df-aafc-6e3405f07f8f)
)

[https://inpa.tistory.com/entry/MYSQL-📚-트랜잭션Transaction-이란-💯-정리](https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)

트랜잭션은 다음과 같은 과정을 가진다.

트랜잭션이 시작되면, 활동 상태가 되며, 트랜잭션이 정상적으로 실행되고 있음을 의미한다.

이 때, 작업이 성공하면, 활성 상태에서 Partially Commited 상태가 된다. 이 상태는 Commit 연산이 실행되기 직전으로, 작업이 성공했다고 무조건 반영하는 것이 아닌, 실제 DB에 작업 내용을 반영하지 않고 기다리는 상태를 말한다.

이후에 반영을 승인하는 상태를 Commit이라고 하며 이로써 트랜잭션이 성공적으로 종료된다.

작업 실패 과정은 다음과 같다. 하나는 트랜잭션 실행 자체에 오류가 발생해 중단된 상태로 Failed를 의미한다. 이후 트랜잭션이 비정상적인 종료를 해 Rollback 연산을 수행한 상태를 Aborted라고 한다. 이 Rollback을 수행하면 트랜잭션 내부의 작업을 수행 이전의 상태로 되돌린다.

---

DDL : Data Definition Language

- Create, Drop, Truncate, Alter

DML : Data Manipulation Language

- Select, Insert, Update, Delete

DCL : Data Control Language

- Grant, Revoke

DDL은 트랜잭션의 롤백 명령이 적용되지 않는다.

---

## 병행수행(Concurrency)

: DBMS는 여러 유저가 DB를 동시에 공유할 수 있도록 병행수행을 지원한다.

- 트랜잭션이 서로 다른 데이터를 사용할 때는 문제가 없으나, 동시에 같은 데이터에 접근해서 Read, Write를 한다면, 문제가 생길 수 있다.

## 갱신분실(Lost Update, Dirty Write)

<aside>

하나의 트랜잭션이 수행한 연산의 결과를 다른 트랜잭션이 덮으면서 변경된 연산이 무효화되는 것.

</aside>

두 트랜잭션이 있다고 가정한다.

| 트랜잭션 A | 트랜잭션 B |
| --- | --- |
| read(account); account = account + 10; |  |
|  | read(account); account = account + 11; |
| write(account); |  |
|  | write(account); |

다음과 같은 순서로 트랜잭션이 실행됐을 때, account의 값은 어떻게 될까.

트랜잭션 B가 account이 갱신되기 이전의 값을 read한 후에 갱신을 했다.

이로 인해, 결국, A가 write한 값은 무효가 되면서 갱신 자체가 분실이 되었다. 이를 **갱신분실**이라 한다.

- 왜 이런 일이 벌어진걸까?
    
    DB에 저장된 데이터는 일단 주기억장치의 **버퍼**로 가져와야 읽을 수 있다. 트랜잭션은 버퍼에 저장된 데이터로 작업을 진행한다. 추후 버퍼의 내용을 DB에 기록하는 작업은 DBMS의 임무다. 위의서의 트랜잭션을 과정을 좀 더 풀면 다음과 같다.
    
    | 트랜잭션 T1 | 트랜잭션 T2 | 버퍼의 데이터 값 |
    | --- | --- | --- |
    | A = read_item(x); A = A - 100; |  | x = 1000 |
    |  | B = read_item(x); B = B + 100; | x = 1000 |
    | write_item(A → x); |  | x = 900 |
    |  | write_item(B → x); | x = 1100 |

이를 해결하기 위해서는, 트랜잭션 A의 수행이 완수된 후에 B를 수행할 수 있도록 해야 각 트랜잭션이 수행한 결과를 모두 반영할 수 있다. 이를 해결하고자 합리적인 사고를 해본다면, 두 트랜잭션이 시간차를 두고 T1 → T2 혹은 T2 → T1 식으로 순서대로 실행하면 될 것이다. 하지만 DB의 공유와 빠른 응답 처리를 하기 위해서는 그럴 수가 없다는 것은 자명하다.
해결 방법으로는 낙관적 락, 비관적 락, 트랜잭션 격리 수준 설정이 있다.

## 모순성(Inconsistency, Non-repeatable Read)

<aside>

트랜잭션이 변경 연산을 시행할 때, 일관성 없는 상태의 데이터를 사용해 연산함으로써 발생하는 모순된 결과를 말한다.

</aside>

두 트랜잭션이 있다고 가정한다. (T1, T2)

계좌 A와 계좌 B가 있다고 가정한다. A의 초기 잔액 : 1000원, B의 초기 잔액 : 2000원

트랜잭션 T1

1. 계좌 A에서 300원 인출 ( A = A - 300)
2. 계좌 B에 300원 입금 ( B = B + 300)

트랜잭션 T2

1. 전체 잔액 계산 ( A + B )

수행

1. T1이 계좌 A에서 300원을 인출해 A에는 700원이 남아있다. → 커밋되지 않은 상태.
2. T2가 계좌 A(700원)과 B(2000원)을 읽어 전체 잔액을 계산 : 2700원
3. T1이 계좌 B에 300원을 입금해 B에는 2300원이 있다. → 커밋

결과

즉, 정상적으로는 3000원으로 계산해야 하나, 동시 수행하며 모순이 발생해 2700원이 계산되었다.

### 모순성 방지 방법

1. 트랜잭션 격리 수준(Isolation Level) 설정
    1. Repeatable Read 또는 Serailizable 격리 수준을 사용하면 트랜잭션이 **완료되기 전**의 데이터가 **다른 트랜잭션에 노출되지 않는다**.
2. 읽기 작업 분리
    1. 트랜잭션 내에서 읽기 작업을 분리해 쓰기 작업의 영향을 받지 않도록 설계한다.
3. 락(Lock) 사용
    1. 데이터를 R/W 하기 전에 **공유 잠금** 또는 **배타 잠금**을 설정해 다른 트랜잭션의 동시 접근을 차단한다.
4. 트랜잭션 순서 조정
    1. 트랜잭션의 병렬 처리를 최소화하고 순차적으로 실행할 수 있도록 한다.

### 갱신분실과 모순성의 차이

- 갱신분실은 데이터의 초기 상태를 여러 트랜잭션이 읽은 후 수정을 할 때 생기는 문제다.
- 모순성은 중간 상태의 데이터를 읽거나 처리 순서의 문제로 데이터 상태가 일관되지 않아 생기는 문제다.

## 연쇄 복귀(Cascading Rollback)

<aside>

트랜잭션 중 어느 하나에 문제가 생겨 Rollback하는 경우 다른 트랜잭션도 함께 Rollback 연산을 실행한다.

</aside>

트랜잭션이 T1, T2, T3가 있다고 가정한다.

T1 : 고객이 주문을 생성.

T2 : 재고를 확인하고 감소한다.

T3 : 결제 처리한다.

과정

1. T1이 성공해 주문 데이터를 생성한다.
2. T2가 실행 중 재고 부족으로 인해 실패한다.
3. T2가 롤백되며, 의존하는 T3 또한 결제 데이터를 생성할 수 없기에 T3를 롤백한다.
4. T1도 롤백하여 주문 데이터가 삭제된다.

결과

T2의 실패로 인해 다른 T1과 T3의 롤백으로 이어져 전체 작업이 취소된다.

### 연쇄 복귀가 데이터 정합성에 문제를 일으키는가?

한 트랜잭션의 실패로 인해 다른 트랜잭션까지 롤백되는 현상이기 때문에, 데이터 정합성 자체는 문제가 없다.

사용자는 쇼핑몰에서 주문을 성공했다라는 메시지를 받지만, 실제로 처리되지 않은 상황을 볼 수 있기 때문에 신뢰 문제가 발생한다.

또한, 시스템 내부에서는 트랜잭션이 롤백되며 다른 작업들이 대기하거나 중단될 수가 있다.

---

## 트랜잭션의 격리 수준

: 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지에 대한 여부를 결정하는 것을 Isolation Level, 격리 수준이라고 한다.

격리 수준은 다음과 같다.

| ↑ | Serializable |
| --- | --- |
|  | Repeatable Read |
|  | Read Committed |
| ↓ | Read Uncommited |

**Serializable** : 말 그대로 순차적으로 트랜잭션을 진행한다. 한 트랜잭션에서 사용하는 데이터는 **다른 트랜잭션에서 접근이 절대 불가능**하며, **가장 엄격**한 격리 수준이다. 그렇기 때문에 데이터 정합성에 문제가 발생하지 않는다는 장점이 있으나, 트랜잭션이 순차적으로 처리되기 때문에 처리 성능이 떨어지는 단점이 존재한다.

**Repeatable Read** : 커밋이 완료된 데이터만 읽을 수 있다. MVCC를 이용해 한 트랜잭션 내에서 동일한 결과를 보장하나, 새로운 레코드가 추가될 때 부정합이 생길 수 있다. 이 한 트랜잭션에서 레코드를 두 번 이상 읽을 때, **Phantom Read**가 발생할 수 있다. 단, 이 문제는 **MVCC** 덕분에 일반적인 조회에서는 발생하지 않고, Lock을 사용했을 때 발생한다.

**Read Commited** : 커밋된 데이터만 조회할 수 있다. Phantom Read + Non-Repeatable Read가 발생할 수 있다.

**Read Uncommitted** : 커밋하지 않은 데이터도 접근이 가능한 격리 수준이다. 다른 트랙잭션의 작업이 커밋 혹은 롤백이 되지 않았어도 즉시 보인다. 이로 인해 Dirty Read 혹은 Lost Update라고 하는 갱신 분실 문제가 여기서 발생한다.

|  | Dirty Read | Non-Repeatable Read | Phantom Read |
| --- | --- | --- | --- |
| Read Uncommitted | 발생 | 발생 | 발생 |
| Read Committed | 없음 | 발생 | 발생 |
| Repeatable Read | 없음 | 없음 | 발생(MySql은 거의 없음) |
| Serializable | 없음 | 없음 | 없음 |

Serializable이 아니라면 성능에서 크게 저하가 발생하지 않는다. 그렇기 때문에 MySql에서는 Repeatable Read를 사용해 정합성을 지키는 것이 올바른 선택이다.

## MVCC

- Multi-Version Concurrency Control로 다중 버전 동시성 제어를 말한다.
- 동시 접근을 허용하는 DB에서 동시성을 제어하기 위해 사용하는 방법이다.
- MVCC는 스냅샷을 이용하는 방식으로, 기존 데이터를 덮어 씌우는 것이 아닌, 기존 데이터를 바탕으로 이전 버전 데이터와 비교해 변경된 내용을 기록한다. 이렇게 함으로써 여러 버전의 데이터가 존재하고 사용자는 결국 마지막 버전의 데이터를 읽는다.

## Lock

### Optimistic Lock

> 자신이 데이터를 수정 중이라는 사실을 알린다. 이를 위한 장치로 Lock을 사용한다.
> 

| 트랜잭션  T1 | 트랜잭션 T2 | 버퍼의 데이터 값 |
| --- | --- | --- |
| LOCK(X) A = read_item(X); 
A = A - 100; |  | X = 1000 |
|  | LOCK(X)
(wait 대기) | X = 1000 |
| write_item(A→X); UNLOCK(X); |  | X = 900 |
|  | B = read_item(X);
B = B + 100;
write_item(B→X);
UNLOCK(X) | X = 1100 |

- 낙관적 락
- DB의 Lock을 사용하지 않고, JPA가 제공하는 Version 관리를 통해 처리한다.
- 트랜잭션 대부분이 충돌하지 않는다고 가정하는 방법이다.
- 트랜잭션 충돌 발생 시 재시도하거나 롤백 처리를 한다. 할 수 있는 이유는, 데이터 충돌이 발생해도, 큰 문제가 없다고 판단하기 때문이다.

### Pessimistic Lock

- 비관적 락
- 데이터 정합성이 매우 중요한 경우
- 데이터를 읽거나 수정하는 동안 다른 트랜잭션의 접근을 차단한다.
- 충돌 가능성이 높은 환경에서 사용한다.
- `Shared Lock`(공유 락) : 읽기 허용, 쓰기는 차단
- `Exclusive Lock`(배타 락) : 읽기, 쓰기 차단

### Distributed Lock

- 분산 락
- 여러 애플리케이션 인스턴스가 동일한 자원에 접근할 때, 단 하나의 노드만 작업을 수행할 수 있도록 보장을 한다.
- Redis, Zookeeper, Consul 같은 도구를 사용해 구현한다.

각각의 락은 비즈니스 요구사항에 따라 적절히 선택해야 한다. 주로 **수정**을 더 많이 한다면 **Pessimistic**을, **읽기**의 비중이 더 높다면 **Optimistic**을 사용한다.


## 🔗 참고 자료
- 갱신분실, 모순성, 연쇄복귀 (https://m.blog.naver.com/bbbisskk2/222963702095)
- 트랜잭션 특성 (https://jindevelopetravel0919.tistory.com/48)
- 트랜잭션 특징 (https://mommoo.tistory.com/62)
- 전반적인 트랜잭션 정리 (https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)
- 트랜잭션 격리 수준 (https://mangkyu.tistory.com/299)
- MySQL로 배우는 데이터베이스 개론과 실습
