
## 📌 트랜잭션이란?
> 트랜잭션이란, 데이터베이스의 상태를 변경시키기 위해 수행하는 작업 단위 또는 한꺼번에 수행되어야 할 일련의 연산들을 의미

> 트랜잭션은 모든 단계가 완료되면, "커밋"되어 데이터베이스에 변경사항이 모두 저장
중간에 문제가 생겨 트랜잭션이 완료되지 못한 경우, "롤백"이 일어나 모든 변경사항이 원상복구
=>  이처럼 트랜잭션은 데이터의 일관성을 보장해주는 굉장히 중요한 역할을 한다. 데이터의 무결성을 유지

ex)
> 은행의 계좌 이체로 예시로 들면, 이체는 송금자의 계좌의 돈을 줄이고 수신자의 계좌의 돈을 늘리는 두 가지 동작이 포함이 된다. 두 동작이 모두 완료되야 커밋이 일어나며, 둘 중 하나라도 오류가 발생한다면 롤백이 일어나 데이터의 일관성을 유지할 수 있다.

### ✅ 특징(ACID)
> - 원자성(Atomicity) : 트랜잭션에 포함된 작업들이 DB에 모두 반영되거나, 전부 반영되지 않아야 한다는 특성.
> - 일관성(Consistency) : 트랜잭션 내의 모든 작업들이 성공적으로 반영된 후, 데이터베이스 상태가 일관성을 유지해야 한다는 의미(한마디로, 돈을 송신을 했을때 금액이 빠지고, 수진자는 그에 맞게 금액이 올라가야한다는 의미)
> - 격리성(Isolcation) : 각각의 트랜잭션은 서로에게 영향을 주지 않아야 한다는 특성이다. 트랜잭션 수행 시, 다른 트랜잭션이 동시에 접근하지 못하도록 하는 특성으로, 이를 보장하기 위해 락과 같은 잠금 매커니즘이 사용.
> - 지속성(Durability) : 트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 반영되어야 한다는 의미 (시스템이 다운되어도 완료된 트랜잭션의 결과는 손실 x)

하지만, 모순되게 ACID를 완벽하게 적용을 하려면 트랜잭션을 한 번에 한개의 트랜잭션만 처리해야 하는데, 이는 효율성면에서 굉장히 떨어진다. 따라서 데이터의 일관성과 성능 사이의 적절한 균형을 맞춰야 함.

이를 위해 격리성(Isolation)수준을 조정해 여러 트랜잭션을 동시에 처리할 수 있게 한다.


---

### ✅ 일관성(Consistency)와 동시성(Concurrency)
> 트랜잭션의 일관성이 완전히 보장될 경우, 응답의 지연이 발생하는 형상이 일어남.
왜냐하면, 트랜잭션이 데이터에 접근하는 순간, 그 데이터는 다른 트랜잭션으로부터 잠기게 되며, 그로 인해 다른 트랜잭션들은 대기 상태에 놓이기 되기 때문이죠. 이렇게 되면 동시에 수행되는 트랜잭션 수는 줄어들게 되며, 결국에는 시스템 처리 성능이 저하되게 된다..

>반대로, 동시성을 높이기 위해서 여러 트랜잭션들을 동시에 데이터에 접근하게 한다면? 이 또한 일관성에 문제가 생길 수 있음.

=> 따라서 데이터베이스에서는 이러한 일관성과 동시성 사이에서의 균형을 이뤄야 한다.

이를 위해서 동시성 제어가 필요!!

이러한 동시성은
#### ✅_**낙관적 동시성 제어/ 비관적 동시성 제어**_
> - 낙관적 동시성 제어 : 같은 데이터를 동시에 수정하지 않을 것으로 가정. 이는 트랜잭션이 락을 설정하지 않는다. -> 트랜잭션이 데이터를 실제로 수정하려고 할때, 그때 자신이 읽은 이후에 데이터가 변경되었는지 확인한다.
    ![](https://velog.velcdn.com/images/wngus4278/post/dfc64aad-87e7-4bd3-be47-44d770bf378f/image.png)
    데이터가 변경되었는지 확인하는 방법은, DB에서 값을 읽고 수정을 위해 update쿼리를 사용 할 때, WHERE절에 바꿀 version정보를 함께 보내주게 됨. 만약, 다른 쓰레드에서 값을 수정해버렸다면, 버전이 바뀌어있을 것이며 그럼 UPDATE하려는 row를 찾지못해 예외가 발생하게 된다. JPA에서 낙관적락을 사용하게 된다면,
    ![](https://velog.velcdn.com/images/wngus4278/post/0d2736da-dbc9-4db3-b037-bf946b00928e/image.png)
    위 사진 과 같이 @entity가 붙어있는 엔티티에 버전을 설정해주게 된다.
    => 이는 데이터의 쓰기 작업은 별로 없으나, 읽기 작업이 많아 동시 접근이 성능이 중요할 때, 사용하게 됨.

> - 비관적 동시성 제어(lock) : 같은 데이터를 동시에 수정할 것으로 가정하고 시작함. 이는 특정 데이터에 대한 작업을 시작할 때 바로 락을 걸게 된다. 그 트랜잭션이 해당 데이터를 사용하는 동안 다른 트랜잭션들은 해당 데이터에 접근을 하지 못하기 때문에, 데이터의 일관성을 유지할 수가 있게됨. 하지만 이렇게 할 경우, 동시에 여러 트랜잭션이 동일한 데이터에 접근하려고 할 경우 대기 시간이 길어지게 된다. 이는 데이터베이스에 특정 행에 대해서 락을 걸기때문에 다른 트랜잭션이 해당 행을 수정 혹은 조회조차 하지못하기에 -> 병목현상이 일어나게 됩니다.
    ![](https://velog.velcdn.com/images/wngus4278/post/daa9fe9d-bda7-4612-bb38-4564d903e688/image.png)
    비관적 락에는 공유락, 베타적락이 존재함. 공유락은 데이터를 읽을 때 같은 공유락끼리 접근을 허용하나, 쓰기 작업은 막습니다.(조회) 베타적락 같은 경우는 락이 끝날 때까지 read/write작업 전체를 막게됩니다.

=> 이렇듯 락은 비관적락과 낙관적락이 존재함. 이를 적절하게 사용하면 동시성과 일관성을 적절히 지킬 수 있게됨. 추가적으로 해당 락들로 불편한 점이 많기 때문에 분산락을 사용하기도 한다.

---

### ✅ 격리 수준 (Isolation)

**격리수준**이랑 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것!

>- READ UNCOMMITED
>- READ COMMITED
>- REPEATABLE READ
>- SERIALIZABLE

#### ✅ READ UNCOMMITTED(가장 낮은 격리 수준)
> 각 트랜잭션에서의 변경 내용이 COMMIT, ROLLBACK 여부와 상관없이 다른 트랜잭션에서 값을 읽을 수 있는 격리 수준.
아래 그림과 같이 Commit이 되지 않은 상태이지만, Update된 값을 다른 트랜잭션에서 읽을 수 있다.

![](https://velog.velcdn.com/images/wngus4278/post/6ffa77bf-61f5-46bc-9194-d72190e1d528/image.png)

=> 해당 격리수준에서는 Dirty Read, Non-Repeatable Read, Phantom Read가 다 발생할 수 있음.

#### ✅ READ COMMITTED

>커밋된 데이터만 읽을 수 있는 격리 상태로, 대부분의 RDB에서 기본적으로 사용되고 있는 격리 수준입니다. 이떄 실제 테이블에서 값을 가져오는 것이 아닌, Undo 영역에 백업된 레코드에서 값을 가져옴.

![](https://velog.velcdn.com/images/wngus4278/post/689888a9-d918-4199-a129-3c2168e5b95a/image.png)

위 사진과 같이 커밋이 되기 전이기 때문에, Undo 영역에 백업된 레코드에서 값을 가져오게 됨. 해당 Read-Committed의 경우 Dirty Read의 문제는 발생하지 않으나, 아래와 같은 문제가 발생하게 됨.

![](https://velog.velcdn.com/images/wngus4278/post/8e128c4d-fe90-42b5-9752-4e069be992d7/image.png)

트랜잭션 1이 커밋 한 이후, 다시 트랜잭션2가 똑같은 테이블의 값을 읽었으나 값이 일관되지않고, 변경되어 있음을 확인할 수 있음. 이는 트랜잭션 내 똑같은 selcet의 값을 가져와야 하는 REPEATABLE READ의 정합성의 어긋나게 됨. 이러한 문제는 입금,출금처리가 진행되는 금전적인 처리에서 주로 발생하게 된다.

#### ✅ REPEATABLE READ(반복 읽기)

> 한 트랜잭션에서 내에서 같은 쿼리를 여러번 실행할 경우, 언제나 동일한 결과를 가져와야 함을 의미하는 격리 수준이다. 이렇게 하기 위하여 트랜잭션마다 고유한 트랜잭션 ID를 부여하고, 이 보다 작은 트랜잭션 번호에서 변경한 데이터만 읽게됨. MVCC방기법으로, 하나의 데이터의 여러 버전을 유지하여 동시성을 향상시키고, 일관성을 보장.

> MYSQL경우, Undo Log를 사용. Undo Log는 데이터의 이전 버전을 저장하는 공간으로, 트랜잭션 도중 데이터의 변경이 필요할 경우 이공간에서 이전 데이터를 가져옴.

> 하지만, Undo Log가 계속 쌓이게 된다면, MYSQL 서버의 처리 성능이 떨어질 수 있기에, 더 이상 필요없다면 삭제해야함.

![](https://velog.velcdn.com/images/wngus4278/post/512c4922-d8e5-4988-baa7-75f4272de1d2/image.png)
위 경우는, Dirty Read, Non Repeatable Read 문제는 발생하지 않으나, Phantom Read문제가 발생하게 됨.

![](https://velog.velcdn.com/images/wngus4278/post/12ab15ce-60b1-481e-b958-371fe1c1e303/image.png)

위와 같은 현상을 방지하기 위해 쓰기 잠금을 걸어야 함.

#### ✅ SERIALIZABLE
> 트랜잭션의 가장 높은 격리 레벨ㄹ, 이때는 트랜잭션이 순차적으로 실행되기 대문에, 이 격리 수준에서는 어떠한 동시성문제가 발생하지않는다. 하지만 DB에서 거의 사용되지 않음. 성능적인 부분이 매우 않좋기 때문이죠.

>- @Transactional(isolation = Isolation.DEFAULT)
>- @Transactional(isolation = Isolation.READ_UNCOMMITTED)
>- @Transactional(isolation = Isolation.READ_COMMITTED)
>- @Transactional(isolation = Isolation.REPEATABLE_READ)
>- @Transactional(isolation = Isolation.SERIALIZABLE)

  
---

### ✅ 동시성 제어로 인해 발생하는 문제점

#### ✅ Dirty Read
> 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경을 읽는 것을 말한다. 이때 해당 트랜잭션이 롤백될 경우 최종 결과값이 비 일관적으로 적용될 가능성이 있다.

만약 트랜잭션 A가 어떤 레코드를 변경하고 커밋을 진행하지 않았으나, 트랜잭션 B가 해당 레코드를 읽어버리면 Dirty Read가 발생한다. 이때 트랜잭션 A가 커밋이 되지않고 롤백이 이뤄진다면, 데이터가 일관되지 못하게 됨.

#### ✅ Non Repeatable Read
> 한 트랜잭션 내에서 같은 쿼리를 두번 수행했을 때,두 쿼리의 결과가 서로 다른 것을 의미함.


예를 들면, 트랜잭션 A가 어떤 레코드를 읽고있는데, 트랜잭션 B가 그 사이에 레코드를 수정하고 커밋을 하게되면, 트랜잭션 A가 다시 select를 했을때 해당 레코드는 커밋이 된 상태이기에 해당 레코드를 일게되어 데이터의 일관성이 깨지게 됨.

#### ✅ Phantom Read
> Phantom Read는 한 트랜잭션 내에서 동일한 쿼리를 두 번 이상 실행할 때, 첫 번째 쿼리에서는 없었던 레코드가 두 번째 쿼리에서 나타나거나 사라지는 현상을 말함.

예를 들어, 트랜잭션 A가 어던 조건을 만족하는 레코드를 검색하는 쿼리를 실행하고, 그 사이 트랜잭션 B가 그 조건을 만족하는 새로운 레코드를 추가하거나 삭제하고 커밋하면, 트랜잭션 A가 다시 같은 쿼리를 실행했을 경우, 레코드가 추가되었거나 삭제가 되어지게 된다.

-> 데이터를 읽은 후 로직을 진행하는데 있어서, 다른 트랜잭션의 Update,insert의 개입으로 다시 읽었을때 데이터의 무결정이 깨지게 된다.


---
<참고>

- https://wookjongbackend.tistory.com/39
- https://mangkyu.tistory.com/269
- https://woonys.tistory.com/240



