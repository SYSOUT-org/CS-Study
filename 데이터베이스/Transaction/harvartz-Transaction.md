# 트랜잭션

## 1. 트랜잭션의 정의
- 단일한 논리적인 작업 단위
- 논리적인 이유(목적)으로 여러 SQL문을 단일 작업으로 묶어서 나눠질 수 없게 만드는 것이 트랜잭션(Transaction)이다.
- 일부만 성공해서는 DB에 반영되지 않는다.

## 2. 트랜잭션 연산
1. **Commit**  
   지금까지 작업한 내용을 DB에 영구적으로 저장하고 트랜잭션을 종료한다.
2. **Rollback**  
   지금까지 작업한 내용을 트랜잭션 이전 상태로 그대로 돌려놓는 것을 의미한다.

## 3. 트랜잭션 상태
1. **활성화 (Active)**  
   트랜잭션이 작업을 시작하여 실행 중인 상태이다.
2. **실패 (Failed)**  
   트랜잭션에 오류가 발생하여 실행이 중단된 상태이다.
3. **철회 (Aborted)**  
   트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태이다.
4. **부분 완료 (Partially Committed)**  
   트랜잭션의 마지막 연산까지 실행하고 Commit 요청이 들어온 직후의 상태로, 최종 결과를 데이터베이스에 아직 반영하지 않은 상태이다.
5. **완료 (Committed)**  
   트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태이다.

---

# ACID

> **ACID라는 트랜잭션 성질을 통해 신뢰할 수 있는 데이터 관리가 가능해졌다.**

## 1. Atomicity (원자성)
### 정의
- "모두 성공하거나 모두 실패하거나"를 보장한다.
- 트랜잭션은 논리적으로 쪼갤 수 없는 작업 단위이기 때문에 내부의 SQL문들이 모두 성공해야 한다.

### 예시
- 하나의 트랜잭션에 두 개의 쿼리문이 있다고 하자. 이 때, 두 번째 쿼리문만 진행되고 첫 번째 쿼리문이 적용되지 않는다면, 트랜잭션의 목적이 달성되지 않는다. 따라서 Rollback을 수행해야 한다.

## 2. Consistency (일관성)
### 정의
- 트랜잭션이 데이터베이스가 정한 규칙이나 규약을 지켰는가를 의미한다.
- DBMS가 Commit 전에 이를 확인하고 위반 여부를 알려준다.

### 예시
- A라는 유저가 80만 원을 가지고 있는데, 100만 원을 인출하려 한다면 -20만 원이 된다. 하지만 계좌에는 음수 값이 허용되지 않는다는 규약이 있다면, 일관성을 해치기 때문에 Rollback을 수행해야 한다.

## 3. Isolation (고립성)
### 정의
- 여러 트랜잭션이 동시에 실행되더라도 각각이 독립적으로 처리되어야 한다.
- 동시성 제어의 주된 목표가 Isolation이다.

### 예시
- 한 트랜잭션이 진행 중일 때, 다른 트랜잭션이 중간 상태의 데이터를 읽으면 값이 잘못될 가능성이 있다. 이를 방지하기 위해 Isolation이 필요하다.

## 4. Durability (지속성)
### 정의
- Commit된 트랜잭션은 DB에 영구적으로 저장된다.
- 영구적이라는 것은 비휘발성 메모리에 데이터를 저장한다는 의미이다.

### 예시
- Commit 완료 후 시스템에 장애가 발생하더라도 Commit된 데이터는 복구할 수 있다.

---

# Isolation Level
- 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것이다.

## 1. Read-Uncommitted
- 아직 Commit되지 않은 데이터를 읽을 수 있다.

### 예시
1. 트랜잭션 A가 DB에서 10만 원을 읽어온다.
2. 트랜잭션 A가 10만 원에서 5만 원을 추가하여 DB에 Write한다.
3. 트랜잭션 B가 15만 원을 읽어올 수 있지만, A가 Rollback하면 문제가 생긴다.

### 문제점
- **Dirty Read**: Commit되지 않은 데이터를 읽을 수 있는 문제

---

## 2. Read-Committed
- Commit된 데이터만 읽을 수 있다.

### 예시
1. 트랜잭션 A가 DB에서 10만 원을 읽어온다.
2. A가 값을 수정한 뒤 Commit하지 않으면, B는 여전히 이전 값을 읽는다.
3. A가 Commit하면, B는 변경된 값을 읽게 된다.

### 문제점
- **Non-Repeatable Read**: 트랜잭션 내에서 같은 데이터를 반복 조회할 때, 서로 다른 값이 나올 수 있는 문제

---

## 3. Repeatable-Read
- 동일 데이터를 반복 조회해도 같은 값을 반환한다.

### 문제점
- **Phantom Read**: 새로운 데이터가 추가되거나 기존 데이터가 사라지는 문제

---
## 4. Serializable
- 가장 엄격한 격리 수준으로, 트랜잭션이 순차적으로 실행된다
- 어떤 부정합 문제도 발생하지 않으나 동시 처리 성능이 매우 떨어진다.

---

# 참고자료
- [YouTube 1](https://www.youtube.com/watch?v=bLLarZTrebU&t=25s)
- [YouTube 2](https://www.youtube.com/watch?v=sLJ8ypeHGlM&list=PLcXyemr8ZeoREWGhhZi5FZs6cvymjIBVe&index=15)
- [망나니 개발자] (https://mangkyu.tistory.com/299)