# 정규화와 반정규화의 균형: 예약 관리 시스템 사례

데이터베이스 설계를 시작할 때, 우리는 보통 **정규화**를 통해 데이터 중복을 제거하고 데이터의 일관성과 무결성을 보장하려고 합니다. 하지만 모든 시스템에서 정규화만이 최선은 아닙니다.  
**성능 문제**나 **데이터 보존 요구**와 같은 현실적인 이유로, 정규화된 구조를 선택적으로 변경하는 **반정규화(Denormalization)**가 필요할 때가 있습니다.

다른 많은 분들이 정규화에 대해서 조사를 하실 것 같아 저는 반정규화에 좀 초점을 맞춰 글을 정리했습니다. 특히 최근 프로젝트에서 반정규화 경험이 좀 있어서 이 사례를 들어 설명해보겠숩니다 !
우선, 

---

## 정규화가 왜 필요한가?

정규화는 데이터를 효율적으로 관리하고 무결성을 유지하기 위해 필요합니다.  

### **정규화의 주요 장점**
1. **중복 제거**  
   데이터를 여러 테이블로 나눠 동일한 정보가 반복 저장되지 않도록 함.
2. **무결성 유지**  
   데이터를 하나의 위치에서만 수정하면 되기 때문에, 데이터 불일치 문제를 방지.

반복 저장안할시 장점이 뭔데? 
1. DB용량 최적화 - 예를 들어, 어떤 500자짜리 문서 레코드가 있다고 해봅시다. 이 문서 레코드를 여기저기 테이블에서 가져다 쓰는데 이 500 varchar길이 데이터를 있는 그대로 ctrl+c,v 해서 쓰면 DB용량이 쓸데없이 낭비될거임.
그냥 문서테이블 만들고 이 곳에만 500짜리 길이 내용 저장하고 다른 테이블들은 이 PK값을 다 FK로 가져다 쓰는게 메모리면에서 효율적일 것임 !

2. 수정에 용이함 - 제 이름 '진명인' 레코드가 여기저기 테이블에 있다고 해봅시다. 근데 제가 개명을 하면? 기존 '진명인'레코드가 있는 곳 가서 다 수정해줘야함. 심지어 동명이인이 있다면 얘는 백수 진명인일까 이름만 같은 멋진 진명인씨일까 모르게될거임...
그래서 역시 User 테이블에 진명인을 속성으로 가진 DB엔티티의 PK를 다른 테이블들이 FK로 가져다 쓰는게 수정에 용이할 것이다 !

하지만 정규화된 설계는 **조인 연산**이 많아지고 성능이 저하될 수 있음. 특히, **자주 조회되는 데이터**나 **역사적 상태를 유지해야 하는 데이터** (스냅샷이라고 생각해도 됨)에서 성능 문제나 설계상의 제약이 발생할 수 있습니다.

---

## 반정규화란?

**반정규화**는 정규화된 데이터베이스에서 성능을 개선하거나 특정 요구사항을 충족하기 위해 데이터를 중복 저장하거나 테이블을 결합하는 설계 방법입니다.
정규화된 테이블을 다시 되돌릴 수도 있고, 애초에 정규화하지 않을 것으로 테이블을 설계할 수도 있을 것.

### **반정규화의 핵심 목표**
1. **조인 연산 최소화**  
   자주 조회되는 데이터를 결합하여 조인 없이 조회 가능.
2. **성능 최적화**  
   읽기 성능을 극대화.
3. **데이터 보존**  
   특정 시점의 데이터를 그대로 유지(데이터 스냅샷).

---

## 미용 중계 플랫폼의 예약 관리 시스템 사례

### **상황 설명**
저는 미용 중계 플랫폼에서 예약 데이터를 관리했습니다.
예약 정보에는 다음과 같은 데이터가 포함됩니다:
- **예약자 정보**
- **미용사 정보**
- **미용실 정보**
- **강아지 정보**
- **예약 기본 정보**

일반적인 정규화 설계에서는 다음과 같은 테이블 구조가 될 것입니다:
1. **예약 테이블** (예약의 기본 정보만 저장)
2. **미용사 테이블** (미용사 정보 관리)
3. **미용실 테이블** (미용실 정보 관리)
4. **강아지 테이블** (강아지 정보 관리)
5. **예약자 테이블** (유저 정보 관리)

### **문제점**
정규화된 구조에서는 예약 정보를 조회할 때 **여러 테이블을 조인(Join)**해야 하는 상황이 발생했습니다.
- 예약 정보 조회 시 예약 테이블과 미용사, 미용실, 예약자, 강아지 (총 5개...) 테이블을 조인해야 함.  
- 하지만, 이 예약 정보는 조회가 빈번한 시스템 기능으로 기대되기에ㅡ **조인 연산의 부하**로 인해 성능 저하가 발생할 가능성이 큽니다.
- 또한, 위 연관 테이블들 중에 레코드가 바뀌는게 있다면 예약 시점의 정보와 현재 정보의 불일치로 인해 예약 정보에 혼돈이 생길 수 있습니다. 금액이 걸려있기도 하고, 미용 서비스의 합의된 정보들이 담겨 있기에 여러 문제를 초래할 수 있습니다.

### **해결 방안: 반정규화 설계**
예약 당시의 데이터를 스냅샷처럼 예약 테이블에 그대로 저장합니다:
- **예약자 이름, 미용사 이름, 미용실 이름, 강아지 이름** 등을 `varchar` 필드로 직접 예약 테이블에 저장.  
- 예약 당시의 데이터를 그대로 유지하므로, 조인 없이 예약 테이블만으로 필요한 정보를 모두 조회할 수 있습니다.
- 예약 당시의 데이터를 그대로 유지하므로, 예약 당시 합의된 내용이 있는 그대로 영속됩니다. 예약 서비스 당일 혹은 추후에 생길 문제점들을 방지해줍니다.

---

## 이 설계의 특징

### **장점**
1. **조인 성능 문제 해결**  
   - 예약 정보를 단일 테이블에서 조회 가능.  
   - 읽기 성능이 크게 개선됩니다.
2. **스냅샷 데이터 보존**  
   - 예약 당시의 정보를 유지하므로, 미용실 이름이나 미용사 정보가 변경되더라도 예약 데이터는 영향을 받지 않습니다.

### **단점 및 고려 사항**
1. **데이터 중복 관리**  
   - 동일한 미용사나 미용실 이름이 여러 예약 데이터에 중복 저장됩니다.  
   - 미용사나 미용실 정보가 변경될 경우, 예약 테이블의 데이터 동기화가 필요할 수 있습니다. (네이버 예약의 경우 이전 데이터를 스냅샷으로 가지고 있되, 해당 매장 이름을 클릭해서 정보들이 최신화된 매장상세 페이지로 넘어가도록 했습니다. 또한, 넘어가기 이전에도 현재 페이지에 동기화되지 않은 정보들이 있다면 경고문을 띄워줍니다. "해당 매장 정보가 없습니다")
2. **무결성 문제**  
   - 데이터가 중복 저장되므로, 잘못된 업데이트로 인해 불일치가 발생할 가능성이 있습니다. (어디 테이블은 최신화된 정보가 담겨있고, 어디 테이블은 최신화 안됐고... 심지어 한 테이블 내에서도 이러한 불일치가 발생할 수 있음)

---

## 정규화와 반정규화의 균형

### **정규화가 적합한 경우**
- 데이터 변경이 자주 발생하고, 중복 데이터로 인해 관리 비용이 증가할 때.  
- 데이터 무결성이 최우선인 경우.

### **반정규화가 적합한 경우**
- 조회 작업이 많고, 조인 연산이 성능 병목으로 작용할 때.  
- 데이터의 스냅샷을 유지하거나, 읽기 성능을 최적화해야 할 때.

---

## 결론
정규화와 반정규화는 "어느 하나가 절대적으로 옳다"는 개념이 아닙니다. 데이터 무결성과 성능 요구사항 간의 **균형을 유지하며 설계**하는 것이 가장 중요한 전략이다 !
